<!doctype html>
<html>
  <head>
    <title>React et la performance Web - Meetup Gandi du 4 septembre 2018 - Timothée Pillard et Julien Wajsberg</title>
    <meta charset="utf-8">
    <link rel='stylesheet' href='fonts/zilla/zilla.css' />
    <link rel='stylesheet' href='fonts/fira/fira.css' />
    <link rel='stylesheet' href='style.css' />
    <link rel="stylesheet" href="./lib/mermaid.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle, cover

# React et la performance Web
## Quelques astuces pour éviter les problèmes

---

# Timothée

.flex[
![Timothée](images/timothee.jpg)

* Timothée Pillard [@tpillard](https://twitter.com/tpillard)
* à Gandi depuis ~4 ans
* développe des trucs sur les sites Web de Gandi: site public
, espace client, shop...
]

---

# Julien

.flex[
![Julien](images/julien.jpg)

* Julien Wajsberg [@jwajsberg](https://twitter.com/jwajsberg)
* à Mozilla depuis plus de 5 ans
* développeur sur [perf.html](https://github.com/devtools-html/perf.html/)
depuis plus d'un an
]

---

# On va parler de...

1. React
2. Redux
3. (si on a le temps) du SSR
4. à retenir !

---

class: center, middle

# Parlons un peu de React

---
# Un composant React simple

Une classe qui étend `Component`, avec une fonction `render` qui retourne un JSX:

```javascript
class Application extends React.Component {
  render() {
    return <div>{this.props.content}</div>;
  }
}
```

---
# JSX, c'est pas magique

JSX est transpilé, généralement par Babel, vers du JavaScript:

```js
class Application extends React.Component {
  render() {
    return React.createElement(
      'div', null, this.props.content
    );
  }
}
```


---
# Un composant React simple
## Style *stateless* ou *fonctionnel*

Une fonction qui prend un objet en paramètre et retourne un JSX:

```js
function Application(props) {
  return <div>{props.content}</div>;
}
```

Contrairement à une croyance répandue, **ce n'est pas** particulièrement optimisé
par React et c'est exactement équivalent au style précédent.

---
# Comment React fait le rendu
## Premier rendu

Il n'y a qu'une seule manière de déclencher un premier rendu: appeler
`ReactDOM.render`:

```js
ReactDOM.render(
  <Application content='Hello World!'/>,
  document.getElementById('root')
);
```

React appelle la méthode `render` de cet élément, puis continue récursivement
avec tous les enfants.

---
# Comment React fait le rendu
## Premier rendu

<div class="mermaid">
graph TD
  Root --> Component
  Component  --> Content
</div>

---
# Comment React fait le rendu
## Updates suivantes

Une update peut être déclenchée par:
1. un nouvel appel à `ReactDOM.render` avec le même composant
2. le `state` d'un composant change avec la méthode `setState`. .smallest[C'est aussi ainsi
que les composants connectés à Redux sont mis à jour.]
3. les `props` d'un composant changent. Cela est forcément une conséquence des
deux premiers cas.

---
# Comment React fait le rendu
## Algorithme de réconciliation

.flex[
<div class="mermaid">
graph TD
  Root --> Component
  Component --> NewContent
  style NewContent fill:#f88
  style Root stroke-width:4px
</div>

.group[
Lorsqu'il y a une update d'un composant, React va appeler la méthode `render` de
ce composant.

Puis il compare cela avec le retour précédent.
]
]
---
# Comment React fait le rendu
## Algorithme de réconciliation

.flex[
<div class="mermaid">
graph TD
  Root --> Component
  Component --> NewContent
  style NewContent fill:#f88
  style Component stroke-width:4px
</div>

Lorsque l'élément au même endroit est du même type, React ne va que changer ses
props si besoin et réaliser une *update* de l'instance existante.
]
---
# Comment React fait le rendu
## Algorithme de réconciliation

.flex[
<div class="mermaid">
graph TD
  Root --> Component
  Component --> NewContent
  style NewContent fill:#f88
  style NewContent stroke-width:4px
</div>

Sinon il va *unmount* l'instance existante et
*mount* une nouvelle instance du nouveau composant.
]
---
# Rappel: cycles de vie
## Mount

.center[
<div class="mermaid">
graph TD
  componentWillMount[componentWillMount / getDerivedStateFromProps]
  construct --> componentWillMount
  componentWillMount --> render
  render --> componentDidMount
</div>
]
---
# Rappel: cycles de vie
## Unmount

.center[
<div class="mermaid">
graph TD
  componentWillUnmount
</div>
]
---
# Rappel: cycles de vie
## Update
.center[
<div class="mermaid" style='height: 50vh'>
graph TD
  componentWillReceiveProps[componentWillReceiveProps / getDerivedStateFromProps]
  componentWillReceiveProps --> shouldComponentUpdate
  shouldComponentUpdate --> componentWillUpdate
  componentWillUpdate --> render
  render --> getSnapshotBeforeUpdate
  getSnapshotBeforeUpdate --> componentDidUpdate
</div>
]
---
# Algorithme de mise à jour: conséquences

1. L'algorithme est joué à chaque update ⇨ attention à ne pas réaliser d'updates
plus souvent que nécessaire.
2. Les méthodes `render` ainsi que les autres méthodes du cycle de vie d'un
rendu sont exécutées à chaque update ⇨ attention à leurs caractéristiques de
performance.
3. L'algorithme lui-même est O(n) d'après les développeurs de React. Donc un
arbre plus gros va linéairement augmenter la durée de l'algorithme.

---
# 1. Ne pas réaliser plus d'updates que nécessaire

Une update sera déclenchée à chaque appel à `setState`. Donc:

* éviter de mettre dans le `state` des choses inutiles au `render`.
* éviter de déclencher trop de `setState` en réponse à des event handlers.
Solution possible: debounce

---
# 2. Attention à la performance de `render`

* traiter le rendu d'une liste: diviser en morceaux ou rendre la liste virtuelle.
* attention aux calculs coûteux: il vaut mieux les faire en amont et stocker le
résultat dans le state.
* c'est la même chose pour `componentWillUpdate`, `componentDidUpdate` etc.
* un `setState` dans `componentDidUpdate` va déclencher un nouveau cycle d'update

---
# 3. Aider l'algorithme de réconciliation à vous aider

* essayer de changer l'état au plus proche du changement d'UI. Redux peut aider
ici.
* `shouldComponentUpdate` et `PureComponent` sont des bons outils pour stopper
la propagation de l'update, en quelque sorte pour "couper" des branches de l'arbre.
* lorsqu'on rend des listes, il ne faut pas oublier de mettre l'attribut *key*.
Cela permet à la réconciliation de retrouver et comparer des éléments **même lorsque l'ordre
change**.

---
# Reparlons de `shouldComponentUpdate`

* appelée au début du processus d'update d'un composant
* si la méthode retourne `false` le rendu est arrêté pour ce composant... et
tous ses enfants
* très bonne manière de diminuer le coût d'une passe de rendu

---
# `shouldComponentUpdate`
## Un exemple

.smallest[
```js
class ComplexPanel extends React.Component {
  // Note: this syntax, new but supported by Babel, automatically binds the
  // method with the object instance.
  onClick = () => {
    this.setState({ detailsOpen: true });
  }

  // Return false to avoid a render
* shouldComponentUpdate(nextProps, nextState) {
    // Note: this works only if `summary` and `content` are primitive data
    // (eg: string, number) or immutable data
    // (keep reading to know more about this)
*   return nextProps.summary !== this.props.summary
*     || nextProps.content !== this.props.content
*     || nextState.detailsOpen !== this.state.detailsOpen;
  }

  render() {
    return (
      <div>
        <ComplexSummary summary={this.props.summary} onClick={this.onClick}/>
        {this.state.detailsOpen
          ? <ComplexContent content={this.props.content} />
          : null}
      </div>
    );
  }
}
```
]

---
# `shouldComponentUpdate`
## Les pièges

* Exécuté à chaque render cycle, donc il doit être performant. Donc pas de comparaison coûteuse.
* Oublier de le modifier lorsqu'on rajoute des propriétés ou du state au
composant. D'où l'intérêt de...

---
# `PureComponent`
## Une implémentation par défaut

Un `PureComponent` n'est qu'un `Component` avec une implémentation de
`shouldComponentUpdate` efficace: elle vérifie si chaque prop et chaque
propriété d'état est strictement égale à sa valeur précédente. Si oui, elle
retourne `false` et le rendu est annulé.

Cela ne fonctionne que si on applique l'*immutabilité* de ces valeurs.
.smallest[plus d'infos dans quelques instants...]

---
# `PureComponent`
## Le même exemple, en plus simple

.smaller[
```js
*class ComplexPanel extends React.PureComponent {
  // Note: this syntax, new but supported by Babel, automatically binds the
  // method with the object instance.
  onClick = () => {
    // Running this repeatidly won't render more than once.
    this.setState({ detailsOpen: true });
  }

  render() {
    return (
      <div>
        <ComplexSummary summary={this.props.summary} onClick={this.onClick}/>
        {this.state.detailsOpen
          ? <ComplexContent content={this.props.content} />
          : null}
      </div>
    );
  }
}
```
]

---
class: center, middle

On appelle *immutabilité* le principe selon lequel on ne change plus le contenu
d'une structure après sa création.

---
class: center, middle

Autrement dit, si on veut changer le contenu d'une structure, on doit *recréer
cette structure*.
--

.smaller[Tout en réutilisant ce qui ne change pas.]

---
class: center, middle

Un exemple ?

---
# Immutabilité
## Un exemple avec un tableau

```js
// Ajouter un élément dans un tableau
stateArray = [...stateArray, newElement];

// Pour changer une propriété du state
this.setState(({ stateArray }) => ({
  stateArray: [...stateArray, newElement],
}));
```
Notez qu'on crée un nouveau tableau, mais on ne recrée pas chacun des éléments
car eux n'ont pas changé.

---
# Immutabilité
## Exemple pour retirer un élément d'un tableau

```js
this.setState(({ stateArray }) => {
  // Removing an element is more involved.
  const newArray = stateArray.filter(
    element => element !== removeElement
  );
  return { stateArray: newArray };
});
```

--

Que se passe-t-il lorsque l'élément n'est pas présent dans le tableau ?

---
class: center, middle

On doit recréer une structure si on veut changer le contenu de cette structure.

---
class: center, middle

On doit recréer une structure *si et seulement si* on veut changer le contenu de cette structure.

---
class: center, middle

Autrement dit: on ne change pas la structure si on ne change pas son contenu !

---
# Immutabilité
## Améliorons l'exemple

```js
this.setState(({ stateArray }) => {
  // Removing an element is more involved.
  const newArray = stateArray.filter(
    element => element !== removeElement
  );

  return {
    stateArray:
*      newArray.length === stateArray.length
*      ? stateArray
*      : newArray
  };
});
```

---
# Trucs à faire attention
## Changer les références par inadvertance
* `array.filter`, `array.map`, ... comme on l'a vu plus tôt
*  `[]`, `{}`:

```js
return selectors.getUsefulData(state) || [];
```

* `function.bind` et fonctions anonymes:

.smaller[
```js
render() {
  return <ComplexContent onClick={() => this.doSomething()} />;
}
```
]

---
class: center, middle

# Et Redux dans tout ca ?
--
## et puis d'abord, _pourquoi_ Redux?
---
# .smaller[La gestion de l'etat d'une application]
### Avant React:
--
.smaller[L'etat est dissemine entre le DOM, des variables globales, Local Storage, etc...]

.smaller[
```javascript
*  var path = window.location.hash;
*  var $tab = $(`.tab[href="#${path}"]`);
   var shouldBeActive = !$tab.hasClass('is-active');
   if (shouldBeActive) {
      $('.tab.is-active').removeClass('is-active');
*     $tab.addClass('is-active');
   }
```
]
---
# .smaller[La gestion de l'etat d'une application]
### Avec React:

.smaller[L'etat est difficile a propager a d'autres composants.]
.smallest[
```javascript
  class Tabs extends React.PureComponent {
    state = { activeTab: 'businesses' }

    handleClick = (evt) => {
      const newActiveTab = evt.currentTarget.href.slice(1);
*     this.setState({ activeTab: newActiveTab });
    }

    render() {
      return (
        <ul>
          {tabs.map((tab) => (
            <li key={`tab-${tab.name}`}>
*             <a onClick={this.handleClick}
*                className={this.state.activeTab === tab.name ? 'is-active' : ''}
                 href={`#${tab.name}`}
              >
                {tab.label}
              </a>
            </li>
          ))}
        </ul>
      );
    }
  }
```
]
---
# .smaller[La gestion de l'etat d'une application]
### Avec React:

.smaller[_“Lift the state UP”_ pattern to the rescue?]
.smallest[
```javascript
  class App extends React.PureComponent {
    tabs = [{ name: 'individuals' }, { name: 'businesses' }, { name: 'developers' }];
    state = { activeTab: 'businesses' };
*    setActiveTab = (newActiveTab) => { this.setState({ activeTab: newActiveTab }); }

    render() {
      return (
*        <Tabs setActiveTab={this.setActiveTab}
*              activeTab={this.state.activeTab}
               tabs={this.tabs}
        />
*        <Content activeTab={this.state.activeTab} />
         <Footer />
      );
    }
  }
```
]

.smaller[Mais cela n'est pas sans consequences! Outre le _"props drilling"_, ce pattern amene forcement a des re-rendus non souhaites, depuis un point haut de l'arbre.]
---
# .smaller[La gestion de l'etat d'une application]
### Avec Redux:
  - Nous permet d'eviter de causer des re-rendus _(setState)_ plus haut dans l'arbre que necessaire.
  - Nous permet d'eviter d'avoir a passer un grand nombre de props tout au long de l'arbre _(props drilling)_.
  - Nous permet d'etablir une unique source de verite, accessible depuis tout point de l'application.

.smaller[Et nous allons voir tres bientot comment mettre tout cela en oeuvre.]
---
# React avec Redux, en pratique
## 1. react-redux `connect`

```javascript
import { connect } from 'react-redux';
```

Nous permet d'introduire la notion de composants _connectes_ (ou _Container_) par opposition aux composants _de presentation_.

.smallest[Note: Vous connaissez probablement cette notion via l'ancienne nomenclature:

_Smart components_ vs _Dumb components_]

---

# React avec Redux, en pratique
## 1. react-redux `connect`

.smallest[
```javascript
connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(Component);
```
]

Connecte un composant React au store Redux, en retournant une *nouvelle classe* de composant.

--

.smaller[
Nous allons maintenant nous interesser aux usages _les plus courants_ de `connect` via ses arguments `mapStateToProps` et `mapDispatchToProps`.
]

.smallest[
```javascript
connect([mapStateToProps], [mapDispatchToProps])(Component);
```
]

.smallest[
Notes:
- [La documentation de `connect`](https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) fait _~20 000_ caracteres et chaque mot y est important.
- On pourrait faire un talk de ~30minutes pour _chacun de ses arguments_.
]

---
# React avec Redux, en pratique
## 1. react-redux `connect`

.smallest[
```javascript
connect(mapStateToProps)(Component);
```
]

Si `mapStateToProps(state, [ownProps])` est defini, le nouveau composant souscrira aux mises a jour du store Redux.

Autrement dit, cette fonction sera appelée apres *toute modification* faite au `state`.

Il est donc _crucial_ que cette fonction soit performante.

.smallest[Des astuces pour rendre cette fonction performante dans quelques instants.]

---
# React avec Redux, en pratique
## 1. react-redux `connect`

.smallest[
```javascript
connect(mapStateToProps)(Component);
```
]

Si votre fonction `mapStateToProps(state, ownProps)` utilise le second argument `ownProps`, alors cette fonction sera *aussi* appelée a chaque fois que ces props changent!

.smallest[
Note: Ce changement de `ownProps` est determine par un test `shallow-equality`.
]

.smaller[Il est donc _doublement crucial_ que cette fonction soit performante, et de n'utiliser l'argument `ownProps` uniquement lorsque *necessaire*.]

.smaller[Attention donc a l'utilisation de cet argument pour des transformations de proprietes.]
---
# React avec Redux, en pratique
## 1. react-redux `connect`

.smallest[
```javascript
connect(null, mapDispatchToProps)(Component);
```
]

.smaller[
`mapDispatchToProps(dispatch, [ownProps])` vous permet d'injecter des _bound action creators_ sous forme de `props`.
]

Si `mapDispatchToProps(dispatch, ownProps)` utilise le second argument `ownProps`, alors cette fonction sera *aussi* appelée a chaque fois que ces props changent!

.smallest[
Note: Si vous utilisez cette syntaxe, il y a de grandes chances pour que vous retourniez de nouvelles références a chaque fois.
]

.smallest[
Note: Ce changement de `ownProps` est determine par un test `shallow-equality`, de la meme manière que pour `mapStateToProps`.
]

.smallest[
_ProTip shorthand syntax_: `mapDispatchToProps = { doStuff: doStuffActionCreator }`;
]
---
# React avec Redux, en pratique
## 1. react-redux `connect`

.smallest[
```javascript
connect(mapStateToProps, mapDispatchToProps, [mergeProps], [options])(Component);
```
]

Ok. Qu'en est-il du rendu de ces composants connectés?

--

Par défaut, `connect(...)(MyComponent)` effectuera un `render` _si et seulement si_ les nouvelles `mergedProps`
(résultat de la fusion de `ownProps`, `stateProps` et `dispatchProps`) ne sont pas `shallow-equal` a leur version précédente.

.smaller[
Note: Pour en savoir plus sur les comportements autres que celui par défaut, voir la documentation des arguments `mergeProps` et `options`.
]

---
# React avec Redux, en pratique
## 1. react-redux `connect`

.smallest[
  ```javascript
  import { connect } from 'react-redux';

  const setActiveTabActionCreator = (tab) => ({ type: 'SET_ACTIVE_TAB', tab });

  export function Tabs({ activeTabName, tabs, dispatch }) {
    return (
      <ul>
        {tabs.map((tab) => (
          <li key={`tab-${tab.name}`}>
            <a onClick={() => { dispatch(setActiveTabActionCreator(tab.name)) }}
                className={activeTabName === tab.name ? 'is-active' : ''}
                href={`#${tab.name}`}
            >
              {tab.label}
            </a>
          </li>
        ))}
      </ul>
    );
  }

  const selectActiveTab = state => state.activeTab;
  const mapStateToProps = (state) => ({ activeTabName: selectActiveTab(state) });
  export default const ConnectedTabs = connect(mapStateToProps)(Tabs);
  ```
]
---
# React avec Redux, en pratique
## 1. react-redux `connect`

.smaller[Injecter des *action creators* en `props` avec `connect`]
.smallest[
```javascript
  import { connect, bindActionCreators } from 'react-redux';
*  import { setActiveTabActionCreator } from './actions';

*  export function Tabs({ activeTabName, tabs, setActiveTab }) {
    return (
      <ul>
        {tabs.map((tab) => (
          <li key={`tab-${tab.name}`}>
*            <a onClick={() => { setActiveTab(tab.name) }}
                className={activeTabName === tab.name ? 'is-active' : ''}
                href={\`#${tab.name}\`}
             >
              {tab.label}
            </a>
          </li>
        ))}
      </ul>
    );
  }
  
*  const mapDispatchToProps = ({ setActiveTab: setActiveTabActionCreator });
*  export default const ConnectedTabs = connect(mapStateToProps, mapDispatchToProps)(Tabs);
```
]
---
# React avec Redux, en pratique
## 1. react-redux `connect`

Dans les deux cas, l'usage de *ConnectedTabs* reste le meme:

  ```javascript
  ...
  render() {
    const tabs = [{
      name: 'developers',
      label: 'Developers! Developers! Developers!',
    }];

    return (
      ...
      <ConnectedTabs tabs={tabs} />
    );
  }
  ```
---
# React avec Redux, en pratique
## 2. Les selecteurs
.smallest[
```javascript
  // {
  //   tabs: [{
  //     name: 'developers',
  //     label: 'Developers, developers, developers'
  //   }]
  // }
  const selectTabs = (state) => state.tabs;
```
]

--
.smallest[
```javascript
  const selectOneTab = (state, name) =>
    selectTabs(state).find((tab) => tab.name === name);
```
]
--
.smallest[
```javascript
  const selectOneTranslatedTab = (state, name) => {
    const tab = selectOneTab(state, name);
    return tab && { ...tab, translated_label: translate(tab.name) }
  };
```
]
---
# React avec Redux, en pratique
## 2. `createSelector`
.smallest[
```javascript
  // {
  //   tabs: [{
  //     name: 'developers',
  //     label: 'Developers, developers, developers'
  //   }]
  // }
  const selectTabs = (state) => state.tabs;
```
]

--
.smallest[
```javascript
  const passName = (state, name) => name;
  const selectOneTab = createSelector(
    [selectTabs, passName],
    (tabs, name) => tabs.find((tab) => tab.name === name),
  );
```
]
--
.smallest[
```javascript
  const selectOneTranslatedTab = createSelector(
    [selectOneTab, passName],
    (tab) => tab && { ...tab, translated_label: translate(tab.name) },
  );
```
]
---
# React avec Redux, en pratique
## .smaller[2.1 Fonctions `reducer`: une approche naive]
.smallest[
```javascript
function reducer(state, action) {
  if (action.type === 'SET_ACTIVE_TAB') {
    return {
      tabs: state.tabs.map((tab) => ({
        ...tab,
        active: action.activeTab === tab.name,
      })),
    };
  }

  return state;
}
```
]
--
.smallest[
```javascript
function reducer(state, action) {
  if (
    action.type === 'SET_ACTIVE_TAB'
    && action.activeTab !== state.find((tab) => tab.active)?.name
  ) {
    return {
      tabs: state.tabs.map((tab) => (
        tab.activeTab === (action.activeTab === tab.name)
        ? tab
        : {
          ...tab,
          active: action.activeTab === tab.name,
        }
      )),
    };
  }

  return state;
}
```
]
---
# React avec Redux, en pratique
## .smaller[2.2 Fonctions `reducer`: une approche plus saine]

.smallest[
```javascript
  function reducer(state, action) {
    if (action.type === 'SET_ACTIVE_TAB') {
      return {
        activeTab: action.activeTab,
      };
    }

    return state;
  }
```
]

--
.smallest[
```javascript
  function reducer(state, action) {
    if (
      action.type === 'SET_ACTIVE_TAB'
      && action.activeTab !== state.activeTab
    ) {
      return {
        activeTab: action.activeTab,
      };
    }

    return state;
  }
```
]
---
# Merci !

La présentation est disponible en ligne à l'adresse
.smaller[https://julienw.github.io/presentation-react-perf-gandi-2018/index.html]
---
# Annexe

---
# Qu'est-ce que Redux?
--
- Un unique conteneur d'*etat* pour une application
--
- Une unique *source de verite*
--
- L'assurance d'un etat *predictible*
--
- Fonctionne de la meme maniere dans *differents environnements*
--
- Une *testabilite* accrue
--
- Une *experience de developpement* efficace

---
# Redux, en pratique
## Les mots-clef
--
1. `State`: Un objet qui reflete l'etat de notre application
--
2. `Store`: Le conteneur du `state`
--
3. `Action`: Un objet simple qui decrit une modification du `state` a partir d'un `type` et d'une `payload` (optionnelle).
--
4. `Action creator`: Une fonction qui retourne une `action`.
--
5. `Selector`: Une fonction qui prend `(state, [props])` en arguments et retourne une donnee du `state`
--
6. `Reducer`: Une fonction qui prend `(state, action)` en arguments et retourne un *nouveau* `state`

# Redux, OK
## qu'est ce qui change ?
--
.smaller[
1. On n'eparpille plus l'etat de l'application, on le *centralise*
2. Les changements d'etats se font au moyen d'objets simples qui *decrivent le changement*
3. Un changement d'etat est reflete par une fonction *pure* et non une succession d'effets de bord
4. La recuperation de l'etat a un *instant t* s'en retrouve grandement facilitee depuis tout composant de l'application
5. L'expression de l'UI n'importe ou dans l'arbre de composants a partir de l'etat de l'application avec un outil tel que React est *naturel*
]
---
# Performance avec React et Redux
## quand Redux travaille **avec** vous

- Lorsque vous avez un `state` plat et simple
- Lorsque vous pouvez deplacer un changement d'etat au plus proche des composants finaux
- Lorsque vos `selectors` et `mapStateToProps` sont performants, memoizes et appliquent le principe d'immutabilite

---
# Performance avec React et Redux
## quand Redux travaille **contre** vous

- Lorsque vous avez un etat profondement nested, avec des structures de donnees complexes
- Lorsque vous connectez des composants qui sont trop eloignes des composants finaux
- Lorsque vous dispatchez *trop* d'actions et stockez trop de donnees non utiles a l'UI dans le `state` 

---
# Performance avec React et Redux
## .flex-justify-between[.span[les bonnes pratiques] _the good_]

1. `selectors` & `mapStateToProps` performants
2. Ne pas creer de nouvelles fonctions dans les `mapDispatchToProps`
3. Ne pas creer de nouveau `state` si le contenu de celui-ci est inchange
---
# Performance avec React et Redux
## .flex-justify-between[.span[les pieges et fausses bonnes idees] _the bad_]
1. `selectors` & `mapStateToProps` over-memoized
2. Connecter *trop* de composants.
3. Utiliser le `state` 

---
# Performance avec React et Redux
## .flex-justify-between[.span[les mauvaises pratiques] _the ugly_]
1. Ne pas respecter le principe d'immutabilite dans `mapStateToProps`

---
# Performance avec React et Redux
## .flex-justify-between[.span[dans la vraie vie] _the necessary evil_]
1. Ne pas respecter le principe d'immutabilite dans `mapStateToProps`


    </textarea>
    <script src="./lib/remark.js"></script>
    <script src="./lib/mermaid.min.js"></script>
 <script>
// REMARK
var slideshow = remark.create({
  highlightLines: true,
});

// MERMAID
// Script comes from https://github.com/knsv/mermaid/issues/360#issuecomment-414298027
// don't let mermaid automatically load on start
mermaid.initialize({
  startOnLoad: false,
  cloneCssStyles: false
});

function initMermaidInSlide(slide) {
  var slideIndex = slide.getSlideIndex();
  // caution: no API to get the DOM element of current slide in remark, this might break in the future
  var currentSlideElement = document.querySelectorAll(".remark-slides-area .remark-slide")[slideIndex];
  var currentSlideMermaids = currentSlideElement.querySelectorAll(".mermaid");
  if (currentSlideMermaids.length !== 0) {
    mermaid.init(undefined, currentSlideMermaids);
  }
}

// first starting slide won't trigger the slide event, manually init mermaid
initMermaidInSlide(slideshow.getSlides()[slideshow.getCurrentSlideIndex()])
// on each slide event, trigger init mermaid
slideshow.on('afterShowSlide', initMermaidInSlide);
    </script>
  </body>
</html>
